# 编译器生成“合成默认构造函数”的情况
1. 该类没有任何构造函数，但包含一个类类型的成员变量。
2. 父类带有默认构造函数，子类没有任何构造函数。
3. 类有虚函数，但没有构造函数。
4. 类带有虚基类
5. 定义成员变量的时候赋初值，C++11新语法
```cpp
class Time
{
public:
    int Second{0};  // 定义并初始化成员变量
}
```

## 2.5 拷贝构造函数语义与移动构造函数语义
### 2.5.1 拷贝构造函数语义

当程序员没有定义自己的拷贝构造函数时，编译器会帮助成需要在必要的时候，合成一个拷贝构造函数：
- 有点情况下，编译器可以不合成拷贝构造函数，直接将简单类型 按值拷贝。

1. 类没有拷贝构造函数，但类含有一个有拷贝构造函数的类类型成员变量。
2. 子类没有拷贝构造函数，父类有拷贝构造函数
3. 类有虚函数或者父类有虚函数
4. 类含有虚基类(虚继承)

### 2.5.2 移动构造函数语义
1. 一个类没有定义拷贝构造函数、拷贝赋值运算符、析构函数，编译器会合成“移动构造函数”和“移动赋值运算符”
2. 可以移动的成员：内置类型、拥有移动操作相关函数的类类型。

## 2.6 程序转换语义
程序员书写一些代码，编译器在处理时，会进一步把这些代码拆分，拆分成更容易被理解的代码：
### 2.6.1 定义时初始化对象
```cpp
X x0; // 构造函数
X x1 = x0; // 拷贝构造函数
X x2(x0);  // 拷贝构造函数
X x3 = x0;  // 拷贝构造函数

对于X x3 = x0;
编译器做了两件事：
1. 定义一个对象，为对象分配内存，但编译器内部并不会调用构造函数
2. 直接调用对象的拷贝构造函数
X3::X(x0);
```

### 2.6.2参数的初始化
给函数值传递对象，实参传递给形参时，调用了X类的拷贝构造函数。
即在函数空间内构造了临时对象，在函数返回前析构临时对象。
老编译器：在调用函数前先拷贝构造函数，然后使用引用传递，将对象传入函数内，函数调用结束后再主动析构对象。

### 2.6.3 返回值初始化
返回一个对象：
```cpp
X func()
{
    X x0;
    //...
    return x0;
}
//main():
X my = func();

输出：
构造函数被调用
拷贝构造函数被调用
析构函数被调用
析构函数被调用
```
程序员：
return x0时，使用拷贝构造函数直接构造到了my中

编译器：
1. 安插一个引用参数，函数内先调用构造函数(X x0)，然后使用引用参数调用拷贝构造函数。

## 2.7 程序的优化
返回对象的函数，有对象去接和无对象去接：
无对象去接：函数调用后，临时对象会立即释放
有对象去接：返回的临时对象不会立即析构，而是直接构造到接的对象中，直到接的对象作用域结束才会析构临时对象。

编译器会采取优化，不同的编译器不用的优化策略下，执行结果会不同。

总结：编译器面临一个类对象(哪怕是临时对象)作为另一个类对象初值的情形时，编译器表现会不同。

## 2.8 拷贝构造函数与深浅拷贝
当没有构造函数时，编译器不一定会自动合成默认的构造函数，而是采用bitwise复制。
需要程序员自己书写构造函数的情况：指针变量作为类的成员变量。
即需要深拷贝时

## 2.9 成员初始化列表
### 2.9.1 何时需要初始化列表
1. 成员变量是引用类型
2. 成员变量是const
3. 类继承自一个基类，基类中有构造函数，构造函数里还有参数。
4. 类中成员变量的类型是某个类类型，类类型的构造函数有参数。

### 2.9.2 初始化列表的优势
- 提升程序运行效率
- 主要是类类型放在初始化列表中效率较高，其他简单类型效率基本一致。

### 2.9.3 初始化列表细节探究
1. 初始化列表中的代码可以看作是编译器安插在构造函数之中的。
2. 初始化列表中的代码是在构造函数的函数体代码执行前被执行的。
3. 初始化列表中成员变量的初始化顺序看的是成员变量在类中定义的顺序，而不是在初始化列表中出现的顺序。



