# C++多态
C++ 实现多态主要有两种途径：静态多态（编译时多态）和动态多态（运行时多态）。

## 静态多态（Static Polymorphism）
静态多态在编译期间就能确定调用哪个函数，主要包括以下形式：

1. 函数重载（Function Overloading）：允许在同一作用域内使用相同的函数名，但参数列表必须不同（类型、数量或顺序）。编译器根据传入参数的类型和数量来决定调用哪个版本的函数。

2. 运算符重载（Operator Overloading）：为运算符提供不同的实现，使得运算符可以根据操作数的类型表现出不同的行为。

3. 模板（Templates）：泛型编程的一种形式，允许编写与类型无关的代码。编译器根据传递给模板的具体类型生成具体的函数或类实例，实现了编译时的多态性。

## 动态多态（Dynamic Polymorphism）
动态多态则是在程序运行时决定调用哪个函数，主要依赖于虚函数机制：

1. 虚函数（Virtual Functions）：在基类中声明函数为虚函数（使用 virtual 关键字），并在派生类中重写（Override）这些函数。通过基类的指针或引用指向派生类对象，调用虚函数时，会根据对象的实际类型动态地调用相应的函数实现。

2. 抽象类（Abstract Classes）：包含至少一个纯虚函数（在声明时加上= 0）的类不能被实例化，但可以作为基类被继承，强制要求派生类实现这些纯虚函数，这是实现动态多态的基础结构。

3. RTTI（Run-Time Type Information）：虽然不直接属于多态实现的一部分，但RTTI机制（如 typeid 操作符和 dynamic_cast）可以在运行时查询对象的确切类型，辅助动态多态的实现。

## C++支持多态的方法
1. 隐式转换操作: 把一个派生类的指针转换为一个指向public基类类型的指针(基类指针指向派生类)
```cpp
shape *ps = new circle();
```

2. 由虚函数(virtual function)机制:运行期决定调用哪个虚函数实例。
```cpp
ps->rotate();
```

3. 经由dynamic_cast和typeid运算符转换
```cpp
if(circle *ps = dynamic_cast<circle*>(ps))
```

用途：
- 多态的主要用途是经由一个共同的接口来影响类型的封装, 这个接口一般定义在一个抽象的基类中.
- 基类中不需要重新写出对继承体系中所有类型都共通的行为和操作。


### 动态多态的实现过程
1. 声明虚函数：首先，在基类中声明一个或多个函数为虚函数。这通常通过在函数声明前加上 virtual 关键字完成。例如：
```cpp
class Base {
public:
    virtual void display() = 0; // 纯虚函数
    virtual void showMessage() { cout << "Base Message" << endl; }
};
```
其中，display() 是一个纯虚函数，要求任何派生类都必须重写它；而 showMessage() 是一个普通的虚函数，派生类可以选择是否重写。

2. 继承与重写：派生类继承自基类，并可以选择性地重写（override）虚函数。重写意味着在派生类中提供了一个具有相同签名的新版本函数。例如：
```cpp
class Derived : public Base {
public:
    void display() override { cout << "Derived Display" << endl; } // 重写 display()
    void showMessage() override { cout << "Derived Message" << endl; } // 重写 showMessage()
};
```

3. 虚表与虚指针：编译器为含有虚函数的每个类自动生成一个虚函数表（vtable），这个表是一个函数指针数组，包含了该类及其基类的所有虚函数地址。同时，每个含有虚函数的对象都会有一个隐藏的指针（称为虚指针，vptr），指向该对象所属类的虚函数表。虚表的构造和虚指针的初始化通常发生在对象构造时。

4. 动态绑定（Late Binding）：当通过基类指针或引用调用一个虚函数时，实际调用哪个版本的函数是在运行时决定的。这称为动态绑定或迟后绑定。编译器通过对象的虚指针查找虚函数表，然后根据虚函数在表中的位置调用正确的函数实现。即使是指向派生类对象的基类指针，也能正确地调用派生类的虚函数实现，实现了动态多态性。


## 多态导致类对象的内存布局改变
### 无多态时的内存布局
当一个类不包含虚函数时：
- 对象头部：通常只包含直接的数据成员。对象的大小直接由其数据成员的总大小决定，加上可能的padding（用于对齐）。
- 访问速度：因为函数调用是静态绑定的，编译器在编译时期就能确定调用哪个函数，因此访问速度快。

### 含有多态时的内存布局（动态多态）
当一个类包含虚函数或继承自含有虚函数的基类时：
- 虚函数表指针（vptr）：对象内存布局中会额外包含一个指向虚函数表（vtbl）的指针。这个vptr通常位于对象的最开始位置，但这也取决于具体的编译器实现。
- 虚函数表（vtbl）：不在对象实例内，而是在类的内存区域。它存储了该类及其基类中所有虚函数的地址。
- 对象大小：由于增加了vptr，对象的总大小会比无多态时增加（通常是一个指针大小，如4字节或8字节）。
- 访问速度：虚函数调用需要通过vptr间接访问虚函数表，再根据表中地址调用实际函数，因此相对于静态绑定，动态调用会有一定的性能开销。
- 多态行为：通过基类指针或引用来调用虚函数时，能够根据对象的实际类型执行相应的派生类函数，实现了运行时的多态性。

## this调整与切割
### 指针和引用实现多态
1. 动态绑定：当使用基类的指针或引用指向派生类对象时，通过这些指针或引用调用虚函数时，实际执行的是派生类中重写的函数。这是因为编译器在运行时根据对象的实际类型（而不是引用或指针的类型）来决定调用哪个函数，这就是所谓的动态绑定或晚期绑定。

2. 灵活性与扩展性：使用指针或引用，可以在不修改现有代码的基础上，轻松地替换为指向不同派生类的对象，提高了代码的灵活性和可维护性。

### 直接用对象的限制
1. 静态类型绑定：如果直接创建和使用对象（而非通过指针或引用），那么对象的类型在编译时期就已经确定，调用成员函数时将遵循静态绑定规则，即总是调用该对象类型所定义的函数版本。这意味着即便存在虚函数，也无法在运行时根据对象的实际类型来调整行为，失去了多态性。

2. “切割”（Object Slicing）问题：当将一个派生类对象赋值给基类对象或以基类对象的方式传递时，派生类特有的部分（即超出基类的部分）将会被“切掉”，因为基类对象没有足够的空间来容纳派生类的额外数据成员。这种现象称为“对象切片”。

### 示例说明
假设有一个基类Animal和派生类Dog，且Animal类中有一个虚函数makeSound()。

如果定义一个Animal类型的对象并尝试让它指向一个Dog对象，例如 Animal animal = Dog();，则animal只能访问到Animal类的成员，Dog类特有的行为将被“切掉”。
但如果使用指针或引用，如 Animal* animalPtr = new Dog(); 或 Animal& animalRef = Dog();（注意，这里的构造方式需要修正，实际应为 Animal& animalRef = *new Dog(); 或通过已存在的Dog对象引用），则通过animalPtr或animalRef调用makeSound()时，会执行Dog类中的实现，体现了多态性。


## 总结
1. 只有通过指针(pointer)或引用(reference)的间接处理基类对象, 才支持面向对象程序设计所需的多态性质.
2. C++中, 多态只存在与public 类体系中, nonpublic的派生行为和void*的指针的多态性, 必须由程序员来显式管理.
3. 多态的主要用途是经由一个共同的接口来影响类型的封装, 这个接口一般定义在一个抽象的基类中.
4. 派生类不会新添加虚表指针(vptr, 继续使用基类的指针), 只是覆盖的地址会有所不同.
5. 类型信息的封装并不是维护于指针之中, 而是维护于链接(link)之中, 此链接存在于对象的虚表指针(vptr), 和vptr所指的虚表(virtual table)之间.
6. 编译器必须确保每个对象有一个或一个以上的vptr, 这些vptr的内容不会被基类对象初始化或改变.
7. 一个指针或引用之所以支持多态, 是因为它们并不引发内存中任何与内存相关的内存委托操作, 会改变的只有他们所指内存的"大小和内容解释方式"而已.
8. 将派生类直接用于初始化基类对象时, 派生类对象会被切割以塞入较小的基类类型内存中.