# 构造函数语义学
## 编译器生成“合成默认构造函数”的情况
1. 该类没有任何构造函数，但包含一个类类型的成员变量。
2. 父类带有默认构造函数，子类没有任何构造函数。
3. 类有虚函数，但没有构造函数。
4. 类带有虚基类
5. 定义成员变量的时候赋初值，C++11新语法
```cpp
class Time
{
public:
    int Second{0};  // 定义并初始化成员变量
}
```

## 拷贝构造函数语义
如果一个Class没有声明一个copy constructor，编译器就会隐式声明一个copy constructor，只有编译器需要的时候，编译器才会定义一个copy constructor实例，并合成于程序之中，而编译器需要的时候是指Class不展现出bitwise copy semantics（位逐次拷贝）。即“如果一个Class未定义出copy constructor，编译器就会自动为它产生出一个”这句话是不对的，只有当Class不展现出bitwise copy semantics时编译器才会产生一个。

### 拷贝构造函数被调用的情况
1. 显示以一个object的内容作为另一个类对象的初值
```cpp
X x;
X xx = x;   // 拷贝构造函数
```

2. 当对象被当作参数交给某个函数时
```cpp
extern void foo(X xx);

void bar()
{
    X xx;
    foo(xx);    // 隐式的初始化操作，实参被拷贝构造给形参
}
```

3. 函数传回一个类成员
```cpp
X foo_bar()
{
    X xx;
    // ...
    return xx;  // 函数返回一个类对象，构造函数将返回值复制构造给接收的对象
}
```

### 不展现位逐次拷（即编译器要合成拷贝构造函数）
当程序员没有定义自己的拷贝构造函数时，编译器会帮助成需要在必要的时候，合成一个拷贝构造函数：
- 以下情况是类不会表现出"位逐次拷贝"（bitwise copy）

1. 类没有拷贝构造函数，但类含有一个有拷贝构造函数的类类型成员变量。
2. 子类没有拷贝构造函数，父类有拷贝构造函数
3. 类有虚函数或者父类有虚函数
4. 类含有虚基类(虚继承)

#### 含有虚函数的class
如果一个类含有虚函数，则在编译期间，这个class需要被扩张：（1）增加一个虚函数表，表内包含每一个有作用的虚函数的地址；（2）为每一个class object安插一个指向虚函数表的指针。也就是说，class的object内存模型中就多了一个虚函数表指针的成员，请注意，一旦有了指针成员，执行bitwise copy semantics就要小心了，这会照成很多问题，一种常见的就是浅拷贝问题，当然这不是这篇文章的讨论重点，读者可以自行查阅相关资料。

首先，要明确，在这种情况下（class 含有虚函数），编译器合成一个copy constructor的目的是重新设定在对象拷贝过程中的虚函数表指针的值，使其指向正确的虚函数表。这里分为两种拷贝情形：（1）不涉及类型交叉的对象拷贝，即同类型对象拷贝，如父类的一个对象以其另一个对象作为初值，子类的一个对象也以其另一个对象作为初值；（2）有类型交叉的拷贝，即继承体系中不同层次的对象拷贝，如父类的一个对象以子类的一个对象作为其初值。在这两种情形中，第一种情况可以直接由bitwise copy semantics完成，因为一个Class只有一个虚函数表，其两个object之间的虚函数表指针可以相互进行位逐次拷贝，这是安全的，即编译器不需要合成copy constructor。但是第二种情形就需要编译器合成的copy constructor，因为子类和父类的虚函数表不同，其各自object之间的虚函数表指针不能进行bitwise copy semantics，这是不安全的，那么编译器合成出来的copy constructor的任务就是重新设定父类的虚函数表指针，使其指向自己的（父类）虚函数表。

#### 继承体系中有虚基类
一个class object如果以另一个object 作为初值，而后者有一个虚基类部分（即其继承于虚拟基类），则就会使bitwise copy semantics失效，编译器需要合成一个copy constructor。

同样的，类似于含有虚函数的class，即使继承体系中有虚基类，不涉及类型交叉的对象拷贝时，bitwise copy semantics仍然是有效的。使itwise copy semantics失效的仍然是有类型交叉的拷贝，即“父类的object以其子类的object作为初值时”，这时编译器需要合成一个copy constructor来设定父类对象中虚基类部分的指针或者位置偏移的初值（virtual base class pointer/offset初值）

### 位逐次拷贝（bitwise copy）的情况
1. 基本类型和POD类型：对于基本数据类型（如int、char）和POD类型（Plain Old Data，简单的数据结构，没有自定义构造函数、析构函数等），它们的拷贝通常是位逐次的，直接复制二进制表示。

2. 使用默认的拷贝构造函数和赋值运算符：当一个对象通过默认的拷贝构造函数或赋值运算符被复制时，如果对象中不包含指针或动态分配的内存，拷贝过程可以简化为位逐次拷贝，即直接复制对象的内存布局到新的位置。

## 移动构造函数语义
### 移动构造函数语义
1. 一个类没有定义拷贝构造函数、拷贝赋值运算符、析构函数，编译器会合成“移动构造函数”和“移动赋值运算符”
2. 可以移动的成员：内置类型、拥有移动操作相关函数的类类型。

## 程序转换语意学
程序员书写一些代码，编译器在处理时，会进一步把这些代码拆分，拆分成更容易被理解的代码：
### 定义时初始化对象
```cpp
X x0;       // 构造函数
X x1 = x0;  // 拷贝构造函数
X x2(x0);   // 拷贝构造函数
X x3 = x0;  // 拷贝构造函数

对于X x3 = x0;
编译器做了两件事：
1. 定义一个对象，为对象分配内存，但编译器内部并不会调用构造函数
2. 直接调用对象的拷贝构造函数
X3::X(x0);
```

### 参数的初始化
给函数值传递对象，实参传递给形参时，调用了X类的拷贝构造函数。
即在函数空间内构造了临时对象，在函数返回前析构临时对象。
老编译器：在调用函数前先拷贝构造函数，然后使用引用传递，将对象传入函数内，函数调用结束后再主动析构对象。

### 返回值初始化
返回一个对象：
```cpp
X func()
{
    X x0;
    //...
    return x0;
}
//main():
X my = func();

输出：
构造函数被调用
拷贝构造函数被调用
析构函数被调用
析构函数被调用
```
程序员：
return x0时，使用拷贝构造函数直接构造到了my中

编译器：
1. 安插一个引用参数，函数内先调用构造函数(X x0)，然后使用引用参数调用拷贝构造函数。

## 程序的优化
返回对象的函数，有对象去接和无对象去接：
无对象去接：函数调用后，临时对象会立即释放
有对象去接：返回的临时对象不会立即析构，而是直接构造到接的对象中，直到接的对象作用域结束才会析构临时对象。

编译器会采取优化，不同的编译器不用的优化策略下，执行结果会不同。

总结：编译器面临一个类对象(哪怕是临时对象)作为另一个类对象初值的情形时，编译器表现会不同。

## 拷贝构造函数与深浅拷贝
当没有构造函数时，编译器不一定会自动合成默认的构造函数，而是采用bitwise复制。
需要程序员自己书写构造函数的情况：指针变量作为类的成员变量。
即当涉及到指针时，必须要有自己的拷贝构造函数进行深构造，为指针分配内存。

## 成员初始化列表
### 何时需要初始化列表
1. 成员变量是引用类型，引用必须在构造时(初始化时)就需要绑定对象。
2. 成员变量是const
3. 类继承自一个基类，基类中有构造函数，构造函数里还有参数。
4. 类中成员变量的类型是某个类类型，类类型的构造函数有参数。

### 初始化列表的优势
- 提升程序运行效率
- 主要是类类型放在初始化列表中效率较高，其他简单类型效率基本一致。
  1. 对于类类型的提升明显，因为生成临时对象再析构开销较大。
  2. 内置类型不明显。
  3. 尽可能使用初始化成员列表。

### 初始化列表细节探究
1. 初始化列表中的代码可以看作是编译器安插在构造函数之中的。
2. 初始化列表中的代码是在构造函数的函数体代码执行前被执行的。
3. 初始化列表中成员变量的初始化顺序看的是成员变量在类中定义的顺序，而不是在初始化列表中出现的顺序。
    - 如果有类类型成员类型，在进入函数体前，类类型成员类型就已经被调用默认构造函数生成了。
	- 如果函数体内初始化，则会产生一个临时对象进行拷贝赋值运算符，效率很低。因此最好使用初始化列表进行调用该类类型的构造函数。
	- 当使用初始化列表时，则会直接调用构造函数，提高了效率。
	- 可以把初始化列表理解为函数体内的正常语句。只是在所有的代码前执行。

