# 关于对象
## 什么是C++对象模型:
语言中直接支持面向对象程序设计的部分,对于各个支持的底层实现机制
本书是C++第一套编译器cfront的设计者所写(了解C++对象模型, 有助于在语言本身以及面向对象观念两方面层次提升)
explicit(明确出现于C++程序代码)
implicit(隐藏于程序代码背后)

## C++对象模式(The C++ Object Model)

```cpp
#include <iostream>
using  std::ostream;
 
class Point {
    public:
    Point(float xval);                            // 构造函数
    virtual ~Point();                             // 虚析构函数
 
    float x() const;                              // 非静态函数（只读）
    static int PointCount();                      // 静态函数
 
protected:
    virtual ostream& print(ostream& os) const;    // 虚函数（只读）
 
    float _x;                                     // 非静态变量
    static int _point_count;                      // 静态变量
} ;
 
 
int main(int argc, char** argv) {
 
 
    system("pause");
    return 0;
}
```
- 每个非内联(non-inline)成员函数只会诞生一个函数实例. 而内联函数会在每个使用者身上产生一个函数实例.
- C++在布局以及存取时间上的额外负担主要由虚(virtual)引起的:
    1. 虚函数机制(virtual function)用于支持一个有效率的运行期绑定(runtime binding).
    2. 虚基类(virtual base class) 用以实现多次出现在继承体系中的基类, 有一个单一而被共享的实例.
    3. 额外负担, 派生类转换.
- 在C++ 中，有两种静态的数据成员（static）、非静态的数据成员（nonstatic）；
- 有三种成员函数：静态的函数（static）、非静态的函数（nonstatic）、虚函数（virtual）



### 简单对象模型（A Simple Object Model）
思想：
对象内放着指向成员的指针(原文为slots(元素, 位置, 槽))，而不是放着成员本身。

优缺点：
- 优点：设计简单，指针的大小是固定的，这种模型可以避免“不同类型members需要不同存储空间”的问题
- 缺点：多了一层间接性，空间和执行期效率稍低。
应用：
未实际应用。

### 表格驱动对象模型（A Table-driven Object Model）
思想：
类对象内含指针指向两个表，一个表(数据成员表)存放实际数据，另一个表(成员函数表)内存放函数地址。

优缺点：
- 优点：弹性较大，可以修改成员变量
- 缺点：多了一层间接性，付出了空间和执行效率的代价

应用：
未实际应用，但是member function table这个观念被采用。

### C++对象模型（The C++ Object Model）
思想：
是从简单对象模型派生来的，并对内存空间和存取时间做了优化。
**非静态数据成员**在对象内，**静态数据成员**在对象外，**静态和非静态成员函数**也被放在对象外。
**虚函数** 虚函数利用虚表(vbtl)和虚表指针(vptr)设置.
1. 每一个类产生出一堆指向虚函数的指针，放在表格之中．这个表格被称为**虚函数表(vtbl)**。
2. 每一个类对象被添加了一个指针，指向相关的**虚函数表**。通常这个指针被称为**虚指针(vptr)**
3. vptr的设定(setting）和重置（resetting)都由每一个类的 构造, 析构和copy赋值运算符自动完成(在第5章讨论)。
4. 每个类所关联的 type_info(类型信息)的对象(用以支持runtime type identification，RTTI)也经由**虚表**指出，通常是放在表格的第一个槽(slot)处。

优缺点：
- 优点：空间和存取时间的效率较高
- 缺点：如果非静态成员变量修改，代码需要重新编译。

- 在虚拟继承的情况下, 基类不管在继承串链中被派生多少次, 永远只会存在一个实例.
- class不仅是一个关键字, 它还会引入它所支持的封装和继承的哲学.
- 某种意义上, 在C++中struct和class这两个关键字是可以互换的.
- 基类和派生类的数据成员的布局没有谁先谁后的强制规定, 但使用初始化列表时, 必须保持成员变量顺序的一致性.
- 组合而非继承, 才是把C和C++结合在一起的唯一可行方法.

## 继承模型
虚拟继承：基类不管被派生多少次，永远只会存在一个实例（subobjet），解决菱形继承问题

### 简单对象模型
- 思想：每一个基类在派生类中都有指针指向它。
- 优点是对象的大小不会因为基类的改变而受影响。
- 缺点是间接性

### base table模型
- 思想：对象含有指针指向一张base table，表格中含有每一个基类的地址
- 优点：
1. 每一个对象对于继承都有一致的表现方式：含有base table指针，与基类的大小、个数无关。
2. 可以改变base table，而无需改变对象本身。
- 缺点：间接性

### C++继承模型
- 思想：不运用任何间接性，基类的数据成员直接放在派生类对象中。虚基类另外讨论（直接放会导致多份数据）。
- 优点：没有间接性
- 缺点：基类成员的任何改变，都让用到它的派生类重新编译。

## 对象模型如何影响程序
不同的对象模型会影响程序代码被转化的方式，像如何使用virtual机制等等

## 关键词所带来的差异(A Keyword Distinction )
为了维护与C语言之间的兼容性，重载函数的解决方式变得很复杂
### 关键字的困扰：struct 和 class
struct的默认访问修饰符是public；而class的默认访问修饰符是private。
struct的默认继承方式是public，而class的默认继承方式是private。除此之外使用时没有区别。

### 策略性正确的struct（The Politically Correct Struct）
这里讲述的是在C中，struct没有访问修饰符，因此struct中的成员变量是按声明顺序出现的内存中的，而在C++中，class/struct有访问修饰符，因此成员变量未必是按照声明顺序出现在内存中的。

## 对象的差异(An Object Distinction)
### 三种程序设计范式
- 程序模型：
    - 像C一样，普通的程序
- 抽象数据类型模型（ADT）：
    - 如string类，所谓的抽象由public接口提供。
- 面向对象模型（OO）：
    - C++通过class的pointers和references来支持多态，这种程序设计风格被称为“面向对象”。
    - 在此模型中有一些彼此相关的类型，通过抽象的base class封装起来。

### OO（Object-Oriented，面向对象）和ADT（Abstract Data Type，抽象数据类型）区别：
#### ADT（抽象数据类型）
1. 定义：ADT是对数据结构的一种抽象描述，它关注的是数据类型的逻辑定义，包括数据的存储结构和在此结构上可以执行的操作，而不关心这些操作的具体实现细节。ADT提供了一种封装机制，隐藏了数据的内部表示，只暴露必要的接口给用户。

2. 特点：
- 抽象性：ADT强调的是数据类型的逻辑特性，而不是物理实现。
- 封装性：隐藏数据结构和实现细节，只暴露接口。
- 通用性：ADT的定义独立于任何编程语言，可以用任何支持相应数据结构的语言实现。

3. 示例：栈、队列、列表等都是典型的ADT，它们定义了数据的添加、删除、查看等操作，而不关心这些操作是如何具体实现的。

#### OO（面向对象）
1. 定义：面向对象编程是一种编程范式，它使用“对象”来设计软件，这些对象包含了数据（属性）和操作这些数据的方法（行为）。OO不仅仅是关于数据类型，更是一种软件设计思想，强调通过对象的组合、继承和多态来构建复杂系统。

2. 特点：
- 封装：与ADT相似，但更全面，不仅限于数据，还包括方法的封装。
- 继承：允许创建分层的类结构，子类可以继承父类的属性和方法，并可进行扩展或覆盖。
- 多态：同一种消息可以被不同的对象以不同的方式响应，增加了代码的灵活性和可复用性。

3. 示例：在面向对象的语言如Java或C++中，定义一个“动物”类，可以有“名字”和“年龄”属性，以及“叫”这样的方法。然后，可以创建“狗”和“猫”这样的子类，它们继承自“动物”类，并可以重写或添加新的方法。

### 加上多态
1. 只有通过**指针或引用的间接处理基类对象**, 才支持**面向对象程序设计所需的多态性质**.
2. C++中, 多态只存在与public 类体系中, nonpublic的派生行为和void*的指针的多态性, 必须由程序员来显式管理.

- 隐式转换操作: 把一个派生类的指针转换为一个指向public基类类型的指针(基类指针指向派生类)
```cpp
shape *ps = new circle();
```
- 由虚函数(virtual function)机制:执行期之前无法决定调用哪个rotate实例。
```cpp
ps->rotate();
```
- 由dynamic_cast和typeid运算符转换
```cpp
if(circle *ps = dynamic_cast<circle*>(ps))
```

用途：
- 多态的主要用途是经由一个共同的接口来影响类型的封装, 这个接口一般定义在一个抽象的基类中.
- 基类中不需要重新写出对继承体系中所有类型都共通的行为和操作。

### class object的内存
#### 无多态时的内存布局
当一个类不包含虚函数时：
- 对象头部：通常只包含直接的数据成员。对象的大小直接由其数据成员的总大小决定，加上可能的padding（用于对齐）。
- 访问速度：因为函数调用是静态绑定的，编译器在编译时期就能确定调用哪个函数，因此访问速度快。

#### 含有多态时的内存布局（动态多态）
当一个类包含虚函数或继承自含有虚函数的基类时：
- 虚函数表指针（vptr）：对象内存布局中会额外包含一个指向虚函数表（vtbl）的指针。这个vptr通常位于对象的最开始位置，但这也取决于具体的编译器实现。
- 虚函数表（vtbl）：不在对象实例内，而是在类的内存区域。它存储了该类及其基类中所有虚函数的地址。
- 对象大小：由于增加了vptr，对象的总大小会比无多态时增加（通常是一个指针大小，如4字节或8字节）。
- 访问速度：虚函数调用需要通过vptr间接访问虚函数表，再根据表中地址调用实际函数，因此相对于静态绑定，动态调用会有一定的性能开销。
- 多态行为：通过基类指针或引用来调用虚函数时，能够根据对象的实际类型执行相应的派生类函数，实现了运行时的多态性。

### 切割
#### 指针和引用实现多态
1. 动态绑定：当使用基类的指针或引用指向派生类对象时，通过这些指针或引用调用虚函数时，实际执行的是派生类中重写的函数。这是因为编译器在运行时根据对象的实际类型（而不是引用或指针的类型）来决定调用哪个函数，这就是所谓的动态绑定或晚期绑定。

2. 灵活性与扩展性：使用指针或引用，可以在不修改现有代码的基础上，轻松地替换为指向不同派生类的对象，提高了代码的灵活性和可维护性。

#### 直接用对象的限制
1. 静态类型绑定：如果直接创建和使用对象（而非通过指针或引用），那么对象的类型在编译时期就已经确定，调用成员函数时将遵循静态绑定规则，即总是调用该对象类型所定义的函数版本。这意味着即便存在虚函数，也无法在运行时根据对象的实际类型来调整行为，失去了多态性。

2. “切割”（Object Slicing）问题：当将一个派生类对象赋值给基类对象或以基类对象的方式传递时，派生类特有的部分（即超出基类的部分）将会被“切掉”，因为基类对象没有足够的空间来容纳派生类的额外数据成员。这种现象称为“对象切片”。

#### 示例说明
假设有一个基类Animal和派生类Dog，且Animal类中有一个虚函数makeSound()。

如果定义一个Animal类型的对象并尝试让它指向一个Dog对象，例如 Animal animal = Dog();，则animal只能访问到Animal类的成员，Dog类特有的行为将被“切掉”。
但如果使用指针或引用，如 Animal* animalPtr = new Dog(); 或 Animal& animalRef = Dog();（注意，这里的构造方式需要修正，实际应为 Animal& animalRef = *new Dog(); 或通过已存在的Dog对象引用），则通过animalPtr或animalRef调用makeSound()时，会执行Dog类中的实现，体现了多态性。

### 补充总结
1. 只有通过指针或引用的间接处理基类对象, 才支持面向对象程序设计所需的多态性质.
2. 多态的主要用途是经由一个共同的接口来影响类型的封装, 这个接口一般定义在一个抽象的基类中.
3. 一个指针, 不管它指向那种数据类型, 其本身所需内存大小是固定的, 与计算机的位数一致.
4. 指针类型会教导编译器如何解释某个特定地址中的内存内容及其大小.
5. void*指针能够持有一个地址, 但不能通过 它来操作所指对象, 因为不知道其覆盖怎样的地址空间.
6. 派生类不会新添加虚表指针(vptr, 继续使用基类的指针), 只是覆盖的地址会有所不同.
7. 类型信息的封装并不是维护于指针之中, 而是维护于链接(link)之中, 此链接存在于对象的虚表指针(vptr), 和vptr所指的虚表(virtual table)之间.
8. 编译器必须确保每个对象有一个或一个以上的vptr, 这些vptr的内容不会被基类对象初始化或改变.
9. 一个指针或引用之所以支持多态, 是因为它们并不引发内存中任何与内存相关的内存委托操作, 会改变的只有他们所指内存的"大小和内容解释方式"而已.
10. 将派生类直接用于初始化基类对象时, 派生类对象会被切割以塞入较小的基类类型内存中.
11. C++通过指针(pointer)和引用(reference)来支持多态.