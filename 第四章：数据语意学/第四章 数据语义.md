# 数据语义(The Semantics of Data)
## 数据成员的绑定
可以分为两类：静态绑定（早绑定）和动态绑定（晚绑定）。

### 静态绑定（Early Binding）
静态绑定，也称为早绑定或编译时绑定，发生在编译阶段。在这个阶段，编译器就能确定所有数据成员的确切类型、大小和内存位置。对于非虚数据成员和非虚成员函数，它们的访问在编译时就已经固定下来。例如，当你直接访问一个对象的数据成员时，该数据成员的访问方式（比如偏移量）在编译时就已经计算好，并直接编码到生成的机器指令中。

### 动态绑定（Late Binding）
动态绑定，又称为晚绑定或运行时绑定，是在程序运行时发生的。在C++中，动态绑定主要应用于虚函数。对于虚函数，编译器不知道在编译时应该调用哪个具体实现，因为这依赖于对象的实际类型，而对象的实际类型可能直到运行时才确定（比如通过多态使用基类指针或引用）。因此，虚函数的调用是通过虚函数表（vtable）来实现的，这使得在运行时能够根据对象的实际类型动态地选择正确的函数实现。

对于数据成员，虽然直接的数据访问通常都是静态绑定的，但通过虚函数间接访问数据成员的行为可以受到动态绑定的影响。例如，如果你在虚函数中访问某个数据成员，那么这个访问实际上是通过对象的实际类型（即运行时类型）来决定的，尽管数据成员本身的地址绑定是静态的。

## 程序的内存布局
1. 代码段（Text Segment/Code Segment）:
   存放程序的机器代码，即编译后的可执行指令。这部分内存是只读的，以防止程序在运行时修改自己的代码。
   1. 常量存储区：常量数据（如字符串字面量、编译时常量表达式的结果）被存储在代码段中，这部分内存是只读的，用于存放程序执行过程中不会改变的数据。因此，当我们讨论常量存储区时，它实质上指的是存放程序中固定不变数据的区域，这部分内容在程序加载到内存时被放置在代码段里，与程序的机器代码存放在一起。

2. 数据段（Data Segment）:
   分为初始化数据段和未初始化数据段（BSS段）。
   1. 初始化数据段：存储程序中已初始化的全局变量和静态变量的值。
   2. BSS段（Block Started by Symbol）：存储未初始化的全局变量和静态变量，通常会被自动初始化为0或空指针。
   3. 全局区/静态区:
   这个术语有时与数据段的概念混用，但主要是强调存储全局变量和静态变量的地方。

3. 堆区（Heap）:
   动态内存分配区域，程序在运行时通过如malloc、calloc、new等函数申请的空间就位于此处。程序员需要手动管理这块区域的内存分配和释放，否则可能导致内存泄漏。

4. 栈区（Stack）:
   用于存储函数调用时的局部变量、函数参数、返回地址等。每当函数调用发生时，一个新的栈帧会被压入栈中，函数返回时相应的栈帧会被弹出。栈的分配和释放由编译器自动管理。

5. 动态库加载区域:
   如果程序使用动态链接库（DLL或.so文件），这些库的代码和数据会被加载到此区域。操作系统负责管理这些共享库的加载和卸载。

6. 程序计数器（PC Register）:
   不是内存区域，但与程序执行密切相关，用于存储下一条待执行指令的地址。

7. 寄存器:
   CPU内部的高速存储单元，用于快速存储和访问数据。编译器会尽可能利用寄存器来提高程序性能。
8. 内存映射区域:
   包括文件映射、共享内存等，操作系统可以将磁盘上的文件或其他资源映射到内存中，使得程序可以直接访问这些资源如同访问内存一样。

9. 栈顶指针（Stack Pointer, SP）和基指针（Base Pointer, BP/EBP）:
   这些不是内存区域，但对理解栈的工作原理很重要。SP指向栈顶，BP通常指向当前函数的栈帧底部，用于维护函数调用栈的结构。

## 数据成员布局
C++中的数据成员布局决定了类实例在内存中的存储方式，涉及到数据成员的排列顺序、对齐、以及如何与其他类特性（如虚函数表）集成。
1. 声明顺序与排列：非静态数据成员在对象中的排列顺序与其在类定义中声明的顺序一致。这意味着编译器会按照声明的顺序来分配内存。在同一个访问控制段（如private、protected、public）中，较晚声明的数据成员会分配在较高的内存地址上。
   1. 比较晚出现的成员变量在内存中有更高的地址；
      1. 从低地址向高地址分配/存储
      2. 大端存储和小端存储
         1. 大端：数据的低位保存在内存中的高地址中，数据的高位保存在内存中的低地址中；
         2. 小端：数据的低位保存在内存中的低地址中，数据的高位保存在内存中的高地址中；

2. 内存对齐：为了优化访问速度，数据成员会被对齐到它们自然对齐边界上。例如，一个四字节的整型通常会被对齐到四字节边界。这种对齐可能会导致额外的填充字节插入到数据成员之间，以满足对齐要求。
```cpp
#pragma pack(1) //对齐方式设置为1字节对齐（不对齐）

#pragma pack() //取消指定对齐，恢复缺省对齐；
```

3. 静态数据成员：静态数据成员不在对象实例中存储，而是在程序的全局数据区域或静态区分配。这意味着所有类实例共享相同的静态数据成员实例。

4. 虚函数表：如果类中包含虚函数，编译器会为该类生成一个虚函数表（vtable），它是一个函数指针数组，存储了类中所有虚函数的地址。每个含有虚函数的类实例会包含一个指向这个vtable的指针（称为vptr），通常位于对象的开始位置，但这也依赖于编译器实现。

5. 多重继承：在多重继承的情况下，派生类可能有多个虚函数表指针，分别指向其基类的虚函数表，以支持正确的动态调度。此外，为了确保正确的基类子对象布局，可能还需要额外的偏移量调整。

6. 空对象：即使一个类没有数据成员，编译器也可能为其分配一个字节的空间，以确保每个对象实例都有唯一的地址，这有助于识别空对象。

7. 访问控制：不同的访问控制段（public、protected、private）不会影响数据成员在内存中的物理布局，但会影响成员的访问权限。

8. 位域成员：如果类定义中包含位域，这些成员的布局将根据位域的定义紧密打包，这可能导致非直观的内存布局。

## 数据成员存取
1. 静态成员变量的存取
   1. 静态成员变量，可以当做一个全局量，但是他只在类的空间内可见；引用时用 类名::静态成员变量名
   2. 静态成员变量只有一个实体，保存在可执行文件的数据段的；
   3. 每次地址保持不变(在编译时地址已经分配完毕)，直接通过具体地址读取。
2. 非静态成员变量的存取（普通的成员变量），存放在类的对象中。存取通过类对象（类对象指针）
   1. 保存在栈中：对象名.成员变量
   2. 保存在堆中：对象指针->成员指针
   3. 栈和堆上的数据每次保持不变
   4. 对于普通成员的访问，编译器是把类对象的首地址加上成员变量的偏移值；

## 单一继承的数据成员布局
1. 基类子对象：派生类对象内存的开始部分通常包含了基类的一个子对象。这个子对象包含了基类的所有非静态数据成员，按照基类中声明的顺序排列，并遵循相应的内存对齐规则。如果基类中有虚函数，还会有一个指向虚函数表的指针（vptr）。

2. 派生类特有的数据成员：紧跟在基类子对象之后，是派生类自己定义的非静态数据成员。这些成员同样按照声明的顺序排列，并进行必要的内存对齐。如果有虚函数且基类中已有虚函数，派生类可能会重用基类的虚函数表指针，或者如果派生类新增了虚函数，则可能需要扩展虚函数表并在对象中维护一个新的vptr。

3. 内存对齐填充：在上述各部分之间，可能会插入填充字节以保证每个数据成员以及整个对象的内存对齐要求得到满足。这有助于提高访问效率，尤其是在处理器对非对齐访问有惩罚的系统上。

4. 虚函数表：如果派生类中定义或重写了虚函数，它可能会拥有自己的虚函数表。这个表中包含了派生类重写的虚函数的新地址，以及未重写而继承自基类的虚函数的地址。派生类对象通常包含一个指针指向这个表。

## 多重继承数据布局
1. 基类子对象：每个基类的子对象都会被嵌入到派生类对象中，保持各自基类的布局。这些基类子对象的排列顺序可能依据编译器的具体实现，但一些编译器倾向于按照继承列表中基类出现的顺序来安排。每个基类子对象内包含其自身的非静态数据成员，以及如果有的话，一个指向该基类虚函数表的指针（vptr）。

2. 内存对齐：每个基类子对象的起始位置需要满足其内部数据成员的对齐要求。此外，派生类的开始部分以及各个基类子对象间的布局也会考虑对齐，以确保最佳访问性能。

3. 虚函数表指针（vptr）：在多重继承情况下，可能存在多个虚函数表指针。如果基类中存在虚函数，派生类对象通常需要包含一个或多个指向虚函数表的指针。对于有相同虚函数的基类，编译器可能采用虚基类机制或优化策略（如共享虚函数表指针）来避免重复。

4. 虚基类：如果基类本身也是多重继承的产物，且被继承为虚基类，派生类对象中只会包含一个虚基类的实例，而不是每个直接或间接继承路径上的一个。虚基类表指针（vbptr）可能被用来定位这个共享的虚基类实例，确保正确地访问虚基类的数据成员。

5. 派生类特有的数据成员：在所有基类子对象之后，是派生类自己定义的非静态数据成员，按照声明顺序排列并满足对齐要求。

6. 内存填充：为了确保对齐，编译器可能会在基类子对象之间、基类子对象与派生类数据成员之间插入填充字节。

7. 菱形继承问题：菱形继承是最典型的多重继承问题，即一个类直接继承自两个或更多个类，而这些类又共同继承自同一个基类。C++通过引入虚基类来解决这一问题，确保基类的子对象只被继承一次，避免了数据的重复。


## this 调整深谈
我们要访问一个类对象中的成员，成员的定位是通过：this指针（编译器会自动调整）以及该成员的偏移值，这两个因素来定义；
   这种this指针偏移的调整 都需要编译器介入来处理完成；（编译器自动完成）

如果使用父类指针指向子类对象，编译器会调整父类指针地址进行偏移，偏移到子类对象中继承父类部分的首地址。
如果再将父类指针转换为子类指针，则子类指针地址会被恢复为真正的首地址。

## 虚基类(虚继承/虚派生)
### 虚基类的作用
1. 消除冗余：通过虚继承，确保无论继承路径如何，基类的子对象在派生类中只存在一份实例。这样就避免了数据成员的重复，节省了内存。

2. 解决二义性：在没有虚基类的情况下，派生类尝试访问基类的成员时，编译器无法确定应该使用哪一份基类实例，从而产生二义性错误。虚基类确保派生类对基类成员的访问是明确无误的。

3. 维护一致性：保证了在继承体系中，对基类数据成员的操作具有一致性，避免了操作不同实例可能导致的不一致状态。

### 如何声明和使用虚基类
在派生类的声明中，使用virtual关键字指定对基类的继承为虚继承。例如，假设有类Base，类Derived1和Derived2都从Base派生，而类Final同时继承自Derived1和Derived2，则可以这样声明：
```cpp
class Base {};

class Derived1 : virtual public Base {};
class Derived2 : virtual public Base {};

class Final : public Derived1, public Derived2 {};
```
这里，Base类被声明为Derived1和Derived2的虚基类。在Final类中，Base的成员只有一个实例，消除了重复。

### 虚基类的实现机制
C++编译器通过在对象中添加额外的信息来实现虚基类的机制。具体来说，编译器会在派生类对象中增加一个或多个指针（通常是虚基类表指针vbptr），指向一个虚基类表（vbtable）。这个表记录了虚基类成员在对象中的偏移量，使得无论继承路径如何，都能够正确访问到唯一的基类实例。

#### 虚基类表 vbtable(virtual base table)
1. 作用：虚基类表是编译器生成的一个表格，用于存储虚基类相关的信息，以便在运行时能够正确地访问虚基类的成员。这个表主要用于解决多条继承路径上的基类实例定位问题。

2. 内容：虚基类表通常包含两部分信息：
   1. 偏移量：记录了从派生类对象的起始地址到虚基类实例的偏移量。这意味着，无论继承层次多么复杂，都可以通过这个偏移量找到虚基类的实际位置。
   2. 调整值：在构造函数和析构函数调用序列中，可能需要对虚基类的构造函数和析构函数做特殊处理，以确保只调用一次。调整值帮助确定是否需要跳过某些构造函数或析构函数的调用。

#### 虚基类表指针 vbptr(virtual base table pointer)
1. 作用：虚基类表指针是一个隐藏的指针，存在于每个使用虚继承的派生类对象中。它的主要职责是指向对应的虚基类表，使得在运行时能够通过该指针访问到虚基类表，进而计算出虚基类成员的准确地址。

2. 位置：虚基类表指针的位置取决于编译器的实现，但通常位于对象的头部，紧随（或可能在）虚函数表指针（vptr）之后。这意味着在访问虚基类成员前，需要首先通过vbptr找到vbtable，然后利用其中的偏移量信息来定位虚基类成员。

#### 实现细节
在对象创建时，编译器会初始化vbptr，使其指向正确的虚基类表。
当通过派生类对象访问虚基类的成员时，编译器会首先利用vbptr获取虚基类表，然后计算出虚基类成员的偏移量，最后加上对象的地址得到实际访问地址。
如果一个类既是虚基类又是其他类的虚基类，那么这个类可能有多个虚基类表指针和虚基类表，以处理多层次的虚继承关系。

#### 性能考量
使用虚基类和相应的虚基类表及指针会引入一定的性能开销，特别是在访问虚基类成员时，因为需要间接寻址。然而，对于需要解决多重继承问题的应用场景，这是必要的设计选择。


## 成员变量的地址、偏移、指针等重申
1. 对象成员变量内存地址及其指针
   1. 对象的成员变量是有真正的内存地址的；
2. 成员变量的偏移值及其指针（和具体对象是没有关系的
   1. 大家要知道，成员变量指针里边保存的 实际上是个偏移值（不是个实际内存地址）。
3. 没有指向任何数据成员变量的指针
   1. 通过 一个对象名或者对象指针后边跟  成员变量指针 来访问某个对象的成员变量：
